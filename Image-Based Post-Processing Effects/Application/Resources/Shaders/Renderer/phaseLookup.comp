#version 450 core

layout(local_size_x = 64, local_size_y = 1, local_size_z= 1) in;

layout(rgba16f, binding = 0) uniform writeonly image2D uPhaseLUT;

uniform int uNumPhaseTerms;
uniform vec4 uPhaseParams[4];
uniform int uPhaseFunc[4];

const float PI = 3.1415926535898;

#define NORMALIZE_PHASE_FUNCTIONS 1

float ScatterPhase_Isotropic()
{
    return 1.0 / (4.0 * PI);
}

float ScatterPhase_Rayleigh(float cosa)
{
    float cos_term = cosa * cosa; // ^2
	float phase_term = (3.0 / (16.0 * PI)) * (1.0 + cos_term);
#if NORMALIZE_PHASE_FUNCTIONS
    cos_term *= cos_term; // ^4
    return phase_term * (1.0 - cos_term / 8.0);
#else
    return phase_term;
#endif
}

float ScatterPhase_HenyeyGreenstein(float cosa, float g)
{	
#if NORMALIZE_PHASE_FUNCTIONS
    // "normalized" Henyey-Greenstein
    float g_sqr = g * g;
    float num = (1.0 - abs(g));
    float denom = sqrt( max(1.0 - 2.0 * g * cosa + g_sqr, 0.0) );
    float frac = num / denom;
    float scale = g_sqr + (1.0 - g_sqr) / (4.0 * PI);
    return scale * (frac * frac * frac);
#else
    // Classic Henyey-Greenstein
	float k1 = (1.0 - g * g);
	float k2 = (1.0 + g * g - 2.0 * g *cosa);
	return (1.0 / (4.0 * PI)) * k1 / pow(abs(k2), 1.5);
#endif
}

float ScatterPhase_MieHazy(float cosa)
{
    float cos_term = 0.5 * (1.0 + cosa);
    float cos_term_2 = cos_term * cos_term;           // ^2
    float cos_term_4 = cos_term_2 * cos_term_2;       // ^4
    float cos_term_8 = cos_term_4 * cos_term_4;       // ^8
	float phase_term = (1.0 / (4.0 * PI)) * (0.5 + (9.0 / 2.0) * cos_term_8);
#if NORMALIZE_PHASE_FUNCTIONS
    return phase_term * (1.0 - cos_term_8 / 2.0);
#else
    return phase_term;
#endif
}

float ScatterPhase_MieMurky(float cosa)
{
    float cos_term = 0.5 * (1.0 + cosa);
    float cos_term_2 = cos_term * cos_term;           // ^2
    float cos_term_4 = cos_term_2 * cos_term_2;       // ^4
    float cos_term_8 = cos_term_4 * cos_term_4;       // ^8
    float cos_term_16 = cos_term_8 * cos_term_8;      // ^16
    float cos_term_32 = cos_term_16 * cos_term_16;    // ^32
	float phase_term = (1.0/(4.0 * PI)) * (0.5 + (33.0 / 2.0) * cos_term_32);
#if NORMALIZE_PHASE_FUNCTIONS
    return phase_term * (1.0 - cos_term_32 / 2.0);
#else
    return phase_term;
#endif
}

void main()
{
	float cos_theta = -cos(PI * (float(gl_GlobalInvocationID.x) + 0.5) / 512.0);
	vec3 phase_factor = vec3(0,0,0);
    vec3 total_scatter = vec3(0,0,0);

	// These must match the PhaseFunctionType enum in NvVolumetricLighting.h
	const int PHASEFUNC_ISOTROPIC = 0;
	const int PHASEFUNC_RAYLEIGH = 1;
	const int PHASEFUNC_HG = 2;
    const int PHASEFUNC_MIEHAZY = 3;
    const int PHASEFUNC_MIEMURKY = 4;

    for (int i = 0; i < uNumPhaseTerms; ++i)
	{
        vec3 term_scatter = uPhaseParams[i].rgb;
        total_scatter += term_scatter;
		if (uPhaseFunc[i] == PHASEFUNC_ISOTROPIC)
		{
			phase_factor += term_scatter * ScatterPhase_Isotropic();
		}
		else if (uPhaseFunc[i] == PHASEFUNC_RAYLEIGH)
		{
			phase_factor += term_scatter * ScatterPhase_Rayleigh(cos_theta);
		}
		else if (uPhaseFunc[i] == PHASEFUNC_HG)
		{
			phase_factor += term_scatter * ScatterPhase_HenyeyGreenstein(cos_theta, uPhaseParams[i].a);
		}
		else if (uPhaseFunc[i] == PHASEFUNC_MIEHAZY)
		{
			phase_factor += term_scatter * ScatterPhase_MieHazy(cos_theta);
		}
		else if (uPhaseFunc[i] == PHASEFUNC_MIEMURKY)
		{
			phase_factor += term_scatter * ScatterPhase_MieMurky(cos_theta);
		}
    }
    phase_factor = phase_factor / total_scatter;
	
	imageStore(uPhaseLUT, ivec2(gl_GlobalInvocationID.yx), vec4(phase_factor, 1.0));
}
