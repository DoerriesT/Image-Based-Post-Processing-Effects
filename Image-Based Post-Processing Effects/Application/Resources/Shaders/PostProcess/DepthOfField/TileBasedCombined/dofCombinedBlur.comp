#version 450 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform writeonly image2D uImgOut;

layout(binding = 0) uniform sampler2D uColorTexture;
layout(binding = 1) uniform sampler2D uCocTexture;
layout(binding = 2) uniform sampler2D uCocTileNeighborMaxTexture;
layout(binding = 3) uniform sampler2D uDepthTexture;

uniform vec2 uSampleCoords[7 * 7];

const float Z_NEAR = 0.1;
const float Z_FAR = 3000.0;
const float SOFT_Z_EXTENT = 1.0;

float linearDepth(float depth)
{
    float z_n = 2.0 * depth - 1.0;
    return 2.0 * Z_NEAR * Z_FAR / (Z_FAR + Z_NEAR - z_n * (Z_FAR - Z_NEAR));
}

float softDepthCompare(float a, float b)
{
	return clamp(1.0 - (a - b) / SOFT_Z_EXTENT, 0.0, 1.0);
}

float cone(float dist, float velocityMag)
{
	return mix(0.0, clamp(1.0 - dist / velocityMag, 0.0, 1.0),  sign(velocityMag));
}

float cylinder(float dist, float velocityMag)
{
	return 1.0 - smoothstep(0.95 * velocityMag, 1.05 * velocityMag, dist);
}

void main()
{	
	vec2 invocationSize = gl_WorkGroupSize.xy * gl_NumWorkGroups.xy;
	vec2 texelSize = vec2(1.0 / invocationSize);
	vec2 centerCoord = vec2(gl_GlobalInvocationID.xy + 0.5) * texelSize;
	
	vec2 centerCoc = texture(uCocTexture, centerCoord).xy;

    float centerCocNear = centerCoc.x;
	float centerCocFar = centerCoc.y;
	
	vec2 tileMaxCoc = texture(uCocTileNeighborMaxTexture, centerCoord).xy;
	
	float centerDepth = -linearDepth(texelFetch(uDepthTexture, ivec2(gl_GlobalInvocationID.xy), 0).x);
	
	vec3 sum = vec3(0.0);
	float weight = 0.0;
 
    for (int i = 0; i < 7 * 7; ++i)
    {
		vec2 kernelSampleCoord = uSampleCoords[i];

		vec2 sampleCoordTexels = vec2(gl_GlobalInvocationID.xy + tileMaxCoc.x * kernelSampleCoord);
		vec2 sampleCoord = vec2(sampleCoordTexels + 0.5) * texelSize;
		vec3 sampleColor = texture(uColorTexture, sampleCoord).rgb;
		vec2 sampleCocVals = texture(uCocTexture, sampleCoord).xy;
		float sampleCoc = max(sampleCocVals.x, sampleCocVals.y);
		
		// get depth at sample coord to compare to center depth
		float sampleDepth = -linearDepth(texelFetch(uDepthTexture, ivec2(sampleCoordTexels), 0).x);
		
		// classify as foreground or background, relative to center pixel
		float f = softDepthCompare(centerDepth, sampleDepth);
		float b = softDepthCompare(sampleDepth, centerDepth);
		
		float dist = distance(sampleCoordTexels, gl_GlobalInvocationID.xy);
		
		// weight sample based on sample velocity magnitude and depth
		float alpha = f * cone(dist, sampleCoc)
					+ b * cone(dist, max(centerCoc.x, centerCoc.y))
					+ cylinder(dist, sampleCoc)
					* cylinder(dist, max(centerCoc.x, centerCoc.y))
					* 2.0;
	
		sum += sampleColor * alpha;
		weight += alpha;
    }
 
	vec3 centerColor = texture(uColorTexture, centerCoord).rgb;
    sum = weight > 0.0 ? sum / weight : centerColor;
	
	imageStore(uImgOut, ivec2(gl_GlobalInvocationID.xy), vec4(sum, 1.0));
}